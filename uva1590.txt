题目链接：UVA - 1590 IP Networks

题目大意： 
一个网络地址A和一个子网掩码可以描述一个子网，子网是一个数包含32个二进制位，前n个位为1，后32－n个位为0，如：255.255.255.48(11111111|11111111|11111111|11111000) 表示某个ip地址如果和A的前n位相等则说明其属于这个子网。 
现给定n个网络地址组成一子网，求该子网的最小范围的首地址和子网掩码。

题目思路： 
这道题只要求出ip地址在哪一位最开始存在不同即可解决，通过位运算的异或操作再取反即可得出。 
易错地方： 
所有ip异或一轮之后，得出的结果可能有类似 111110100 的情况出现，不符合掩码的要求； 
位运算的两个小技巧，纪录于此： 
1. a & (a - 1) 将a的二进制位上最后一个1转为0 
2. a | (a - 1) 将a的二进制位上末尾连续的0全部转为1


 scanf("%d.%d.%d.%d", &p[1], &p[2], &p[3], &p[4]);
 
 
代码 ：

#include <stdio.h>
#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <queue>
#include <string.h>
#include <set>
#include <stack>
#include <stdlib.h>
#include <time.h>

using namespace std;

unsigned int num[1009] = {};

int main()
{
    int n;
    while(cin>>n)
    {
        memset(num, 0, sizeof(num));
        for(int i=0;i<n;i++)
        {
            char t[40];
            cin>>t;
            int c = 0;
            for(int j=0;j<strlen(t);j++)
            {
                if(t[j] == '.')
                {
                    num[i] = (num[i]<<8) + c;
                    c = 0;
                }
                else
                    c = c*10 + t[j]-'0';
            }
            num[i] = (num[i]<<8) + c;
        }
        unsigned int ans = ~0, tt;
        for(int i=1;i<n;i++)
        {
            unsigned int q = num[i] ^ num[0];
            while(q)
            {
                ans &= ~(q | (q-1));
                q = q&(q-1);
            }
        }
        tt = ans & num[0];
        int sans[4]={};
        int pos = 0;
        while(tt != 0)
        {
            sans[pos++] = tt%(1<<8);
            tt >>= 8;
        }
        for(int i=3;i>=0;i--)
        {
            cout<<sans[i];
            if(i)
                cout<<".";
        }
        cout<<endl;
        pos = 0;
        memset(sans, 0, sizeof(sans));
        while(ans != 0)
        {
            sans[pos++] = ans%(1<<8);
            ans >>= 8;
        }
        for(int i=3;i>=0;i--)
        {
            cout<<sans[i];
            if(i)
                cout<<".";
        }
        cout<<endl;
    }
    return 0;
}



接到训练题后翻了一遍，第一眼就瞅上这个题了，IP地址，之前培训过几天计算机网络知识，知道子网的划分方法。做题之前首先要了解到什么是子网掩码，子网掩码是子网划分的依据，它跟IP地址一样，长度也是32位，点分十进制表示，每部分0~255，但是跟IP地址不同的是，子网掩码只能由连续的1和0组成，也就是说，把这32位从任意位置分开，左边只能全是1，右边只能全是0。比如11111111.11111111.11111111.11111000（255.255.255.248）就是合法的子网掩码，而11000000.10101000.00000001.00000000（192.168.1.0）就不合法（可以尝试一下在计算机上给网络连接手动分配子网掩码，看看它会怎么提示你）。给定两个IP，假设其子网掩码二进制有x个连续的1，则如果这两个IP的二进制前x位对应相等，那么这两个IP就属于同一网段，也就是属于同一个子网。

如果给定一个子网掩码和一个IP，就可以求出这个IP所在子网的最小IP，方法是将IP的二进制与子网掩码的二进制进行按位与运算，原理是，子网掩码为1的二进制位，要求子网内所有IP的这一位必须全部相等，而子网掩码为0的位不作要求，也就是说，给定一个IP，子网内最小IP对应的子网掩码为1的位必须跟给定IP一样，按位与的时候，给定IP与子网掩码是1的位按位与后的结果不变，子网掩码0的位按位与后为0（恰好是最小），这样按位与运算结束后，得到的IP就是子网内最小IP（说的我自己都有点晕乎了，想弄明白这个，必须了解位运算和子网掩码的相关知识）。

说了这么多，都只是预备知识，下面可以切入正题，给定一些IP地址，求出子网掩码和子网内最小IP。

根据上面所说，这个题只要求出子网掩码，然后与给定的任意IP进行按位与运算，就可以得到最小IP了。那么现在关键就是求子网掩码了，既然给定的这一些IP都是一个网段的，那么找到这些IP里的最小IP和最大IP，然后找到这两个IP的二进制从左往右看哪一位最先出现不同（异或运算可解），就可以知道子网掩码里有几个连续的1，自然就得到子网掩码了，然后最小IP便迎刃而解。所以这个题其实很简单，只要了解点IP地址相关知识即可。

实现方面，写了个ip类，有四部分，分别对应点分十进制的四部分，重载<运算符，sort排序后找到给定IP里的最大和最小，这两个IP每部分依次异或运算得到子网掩码连续的1的个数，得到子网掩码，与任意IP按位与，得到最小IP，个人认为这题的精华是位运算的应用，代码如下：e0405-w.cpp

