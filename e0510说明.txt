 看到该题，最容易想到的方法，就是对于每次请求，都去搜索1500行文档的信息。但是这样效率过低，会超过3秒的限制时间。故这题靠LRJ给出的题目要求还不够，还需要读英文原题，因为原题里有这道题的解题思路。以下是我对前四段话的翻译（本人英语四级未过，不对翻译质量负责~~）：

“搜索引擎（search engine）”这个名词可能对你来说并不陌生。一般来说，它能在互联网的有效(available)网页(pages)上，提取和组织出信息，并反馈(respond)与用户的问题(queries)关联性(relevant)最大的网页。像全球知名的搜索引擎GOOGLE，是我们上网时重要的工具。如下面这段会话，已成为我们日常生活的一部分：

“像这个词语******是什么意思？”
“额...我也不清楚，谷歌一下吧。”

在这道题中，你需要开发一个小搜索引擎。听起来不可思议，不是吗？不用担心，这里会有向导，来一步步教你如何高效地(efficiently)组织(organize)收集（collection）到的大量文本(texts),对一系列的问题作出快速的回应。你不用关心网页(web page)小程序，所有的网页都会以纯文本(text format)作为输入数据(input data)。而且，提供给你系统的问题集一定是合法(validate)的。

现代搜索引擎使用了一种叫“反向(inversion)”的技术来处理大量的文档。这个方法依赖于一种数据结构(data structure)的构造(construction)方式，叫做反向指针(index)，就是标记每个项(term，或者说word)在哪些文档出现过。所有的项组成的集合称为词表（vocabulary），用V来表示(denoted as V)。简单的说，反向指针就是搜索的关键词ω，ω∈V。与其相关的数值是一个指针b(ω)，指向一个作为中介(intermediate)的新增数据结构，叫“桶(bucket)”。桶本质(essentially)上就是一个指针列表，标记出所有出现过的文本集。桶的每个条目(entry)就是文档位置信息(document identifier,DID)，包含了顺序编号(ordinal number)的某个文档及出现在第几行。

       最关键的是上面的最后一段话，我也是艰难的翻译到这里后，瞬间明白题意了，后面的文章只是举例介绍而已。最后要注意，输入的多篇文档，行数总和不会超过1500行。我一开始以为是每篇文档不会超过1500行，把这题做的太难了，还悲剧的RE。
       好吧，上面其实都是废话，这一句也是~~~下面步入主题。


2  基本框架

       如果读者想看明白我的解法，建议这里的讲解和代码要配合看。
       （我这里说的文档，就是LRJ说的“文章”的意思）
       既然总行数少，那么重点应该是放在行操作上。但文档的编号还是对解题有影响的，首先程序输出中，每隔一个文档，要输出10个'-'；其次对“NOT”，"AND”也有比较大的算法干扰。不过有办法克服的，相信这个思路是的对的，故我先定义一个基本的数据类型typedef bool Bit[1505]。然后定义一个叫Index的map<string, Bit>，以文档中出现的每一个单词为key，对应的值为Bit，Bit[i]=1表示这个单词在i行有出现，否则就是没出现。
       同时，定义变量n为文章总数，lines是文档总行数，m是请求总数。用string doc[1505]来存储每行对应的原始内容。所有的编号都是从0开始。
       关于文章编号的处理，定义int limit[105]，limit[i]表示第i篇文档是第几行开始的，有了limit，就能在整个程序中的区分哪些行是哪些文档的，方便对特定文档进行遍历操作。因为整个程序中包含许多这样的操作：将编号为i的文档，遍历其所有的行j，故我把这个for循环写成一个宏定义，简化代码：#define FOR for (int j = limit[i]; j < limit[i + 1]; j++)。


3  解题思路

       分两个大环节，第一个section是：对输入文档信息的初始化操作，包括Index的构建。第二个section是：对每一个请求，给出相应的输出内容。
       第一个环节中，计算出lines，limit都不难。主要是Index的构建：对输入的每行信息（如第p行），要找出里面包含的所有单词，将该单词对应的Bit的第p位记为true（注意Bit建立时每位会自动初始化为false）。这里封装一个函数upDate(string s, int p)来辅助操作，它能将s中的单词对应的Bit的第p位记为true。
       第二个环节中，我引入一个中介变量，Bit mark，mark[j]表示第j行是否需要输出。分两个小节来处理第二环节，第一个subsection得到四种命令中的某种，只需要负责计算出对应的mark，由第二个subsection来负责mark的输出操作。因为这题的输出格式不太容易控制，每输出一个文档要输出一个结束标志，如果对四种命令都写输出语句，会造成很多不必要的重复和代码量过大。
       那么第一个subsection中，如何处理四种命令呢？假设输出的第一个单词对应的Bit是A，第二个单词对应的Bit是B(不一定存在)。那么对于单个单词的查询，mark其实就是A。对于OR操作，只要A与B直接每位进行或操作，就能得到mark，即mark[j] = (A[j]||B[j])。对于NOT操作（比较麻烦），需要使用到前面提到的宏FOR，对每个文档的行进行遍历，如果A[j]的值都是false，代表这篇文章要全部输出，故对应的这块mark[j]都等于true，否则，这块mark[j]都等于false。对于AND操作（最难的一种），也需要对每块单独进行处理，如果这块A和B都有ture的值，代表这篇文档两个单词都有出现，那么这块mark按“OR”同样的方法进行局部赋值，否则这块mark全部等于false。

       讲了这么多，其实我的方法也不是最优的，AC这题用了0.8秒，有个大牛用了0.08秒不知道怎么解的。所以我的方法能不能理解其实关系不大，更重要的是自己思考。我写这么多只是想让以后的自己能看懂~~~


4  求解代码
